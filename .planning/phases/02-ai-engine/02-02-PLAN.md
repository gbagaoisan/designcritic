---
phase: 02-ai-engine
plan: 02
type: execute
wave: 2
depends_on: [01]
files_modified:
  - src/lib/claude.ts
  - src/app/api/critique/route.ts
autonomous: false

must_haves:
  truths:
    - "POST /api/critique with a real image returns a structured critique from Claude"
    - "Critique contains 4 sections (what_works, usability_risks, visual_hierarchy, improvements)"
    - "Each section has 2-4 CritiquePoints with summary and detail"
    - "Critique references specific visual elements in the uploaded image"
    - "Response completes in under 10 seconds"
    - "Invalid requests still return 400 with Zod error messages"
  artifacts:
    - path: "src/lib/claude.ts"
      provides: "getCritique function that calls Claude with image + prompt"
      exports: ["getClaudeClient", "getCritique"]
    - path: "src/app/api/critique/route.ts"
      provides: "POST endpoint calling real Claude API"
      exports: ["POST"]
  key_links:
    - from: "src/lib/claude.ts"
      to: "src/lib/prompts/system.ts"
      via: "import buildSystemPrompt"
      pattern: "import.*buildSystemPrompt"
    - from: "src/lib/claude.ts"
      to: "src/lib/prompts/tool-definition.ts"
      via: "import critiqueToolDefinition"
      pattern: "import.*critiqueToolDefinition"
    - from: "src/app/api/critique/route.ts"
      to: "src/lib/claude.ts"
      via: "import getCritique"
      pattern: "import.*getCritique"
---

<objective>
Replace the mock API response with real Claude API calls using the prompt engine from Plan 01.

Purpose: This is the moment the product comes alive — real AI critiques on real designs. The API route sends the image + composed prompt to Claude, receives structured JSON via tool_use, and returns it to the client.
Output: Working /api/critique endpoint that returns real Claude design critiques.
</objective>

<execution_context>
@/Users/georgebagaoisan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/georgebagaoisan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-ai-engine/02-RESEARCH.md
@.planning/phases/02-ai-engine/02-01-SUMMARY.md
@.planning/research/ARCHITECTURE.md
@.planning/research/PITFALLS.md
@src/types/critique.ts
@src/lib/claude.ts
@src/app/api/critique/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add getCritique function to Claude client</name>
  <files>
    src/lib/claude.ts
  </files>
  <action>
    Modify `src/lib/claude.ts` to add a `getCritique` function:

    Keep the existing `getClaudeClient()` function. Add:

    ```typescript
    import { buildSystemPrompt } from '@/lib/prompts/system';
    import { critiqueToolDefinition } from '@/lib/prompts/tool-definition';
    import type { IndustryContext, CritiqueTone, CritiqueResult } from '@/types/critique';

    export async function getCritique(
      imageBase64: string,
      mediaType: 'image/png' | 'image/jpeg' | 'image/webp',
      context: IndustryContext,
      tone: CritiqueTone
    ): Promise<CritiqueResult> {
      const client = getClaudeClient();
      const systemPrompt = buildSystemPrompt(context, tone);

      const response = await client.messages.create({
        model: 'claude-sonnet-4-5-20250929',
        max_tokens: 4096,
        system: systemPrompt,
        tools: [critiqueToolDefinition],
        tool_choice: { type: 'tool', name: 'design_critique' },
        messages: [
          {
            role: 'user',
            content: [
              {
                type: 'image',
                source: {
                  type: 'base64',
                  media_type: mediaType,
                  data: imageBase64,
                },
              },
              {
                type: 'text',
                text: 'Please analyze this UI design and provide a detailed critique.',
              },
            ],
          },
        ],
      });

      // Extract tool_use response
      const toolUseBlock = response.content.find(
        (block) => block.type === 'tool_use'
      );

      if (!toolUseBlock || toolUseBlock.type !== 'tool_use') {
        throw new Error('Claude did not return a tool_use response');
      }

      return toolUseBlock.input as CritiqueResult;
    }
    ```

    Key implementation details:
    - Use `claude-sonnet-4-5-20250929` model (best speed/quality for vision)
    - `tool_choice: { type: 'tool', name: 'design_critique' }` forces Claude to use the tool (guarantees structured output)
    - Image sent as base64 with correct media_type
    - Include a text message alongside the image to prompt Claude
    - Extract the tool_use block from response.content array
    - The `input` property of tool_use is already parsed JSON (no JSON.parse needed)
    - Cast to CritiqueResult since the tool schema matches the type
  </action>
  <verify>
    Run `npx tsc --noEmit` — no type errors. The function signature and return type should match.
  </verify>
  <done>
    `getCritique` function calls Claude with image + composed prompt, forces tool_use, and returns parsed CritiqueResult.
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace mock API response with real Claude call</name>
  <files>
    src/app/api/critique/route.ts
  </files>
  <action>
    Modify `src/app/api/critique/route.ts`:

    1. Replace `import { getClaudeClient } from '@/lib/claude'` with `import { getCritique } from '@/lib/claude'`
    2. Remove the entire mock critique object
    3. Replace with a real Claude API call:

    ```typescript
    export async function POST(request: NextRequest) {
      try {
        const body = await request.json();
        const parsed = critiqueRequestSchema.safeParse(body);

        if (!parsed.success) {
          return NextResponse.json(
            { error: 'Invalid request: ' + parsed.error.issues.map(i => i.message).join(', ') } satisfies CritiqueError,
            { status: 400 }
          );
        }

        const { image, mediaType, context, tone } = parsed.data;

        const critique = await getCritique(image, mediaType, context, tone);

        return NextResponse.json({ critique } satisfies CritiqueResponse);
      } catch (error) {
        console.error('Critique API error:', error);

        if (error instanceof Error && error.message.includes('ANTHROPIC_API_KEY')) {
          return NextResponse.json(
            { error: 'API key not configured' } satisfies CritiqueError,
            { status: 500 }
          );
        }

        return NextResponse.json(
          { error: 'Failed to generate critique. Please try again.' } satisfies CritiqueError,
          { status: 500 }
        );
      }
    }
    ```

    Key changes:
    - Import `getCritique` instead of `getClaudeClient`
    - Call `getCritique()` with validated request data
    - Wrap in CritiqueResponse shape
    - Add specific error handling for missing API key
    - Add generic error message for other failures
    - Keep Zod validation unchanged (still validates all inputs)
  </action>
  <verify>
    Run `npx tsc --noEmit` — no type errors.
    Run `npm run dev`, then test with a real base64-encoded image:

    ```bash
    # Encode a test image
    IMG=$(base64 -i test-image.png | tr -d '\n')

    # Test the endpoint
    curl -X POST http://localhost:3000/api/critique \
      -H "Content-Type: application/json" \
      -d "{\"image\":\"$IMG\",\"mediaType\":\"image/png\",\"context\":\"saas\",\"tone\":\"constructive\"}"
    ```

    Should return real Claude critique JSON with 4 sections. Response time should be under 10 seconds.

    Also test validation still works:
    ```bash
    curl -X POST http://localhost:3000/api/critique \
      -H "Content-Type: application/json" \
      -d '{"image":""}'
    ```
    Should still return 400.
  </verify>
  <done>
    POST /api/critique sends real images to Claude, receives structured critiques via tool_use, and returns them as CritiqueResponse. Mock data fully replaced. Error handling covers API key issues and general failures.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    The AI engine is live. /api/critique now sends real images to Claude and returns structured design critiques with industry context and adjustable tone.
  </what-built>
  <how-to-verify>
    1. Start dev server: `npm run dev`
    2. Ensure your .env.local has a real ANTHROPIC_API_KEY
    3. Find any UI screenshot (PNG or JPG) and test:
       ```bash
       IMG=$(base64 -i /path/to/your/screenshot.png | tr -d '\n')
       curl -s -X POST http://localhost:3000/api/critique \
         -H "Content-Type: application/json" \
         -d "{\"image\":\"$IMG\",\"mediaType\":\"image/png\",\"context\":\"saas\",\"tone\":\"constructive\"}" | npx json
       ```
    4. Verify the response has 4 sections with specific, actionable feedback
    5. Test roast tone — same image but `"tone":"roast"` — should be witty and direct
    6. Test a different context — try `"context":"healthcare"` — should reference domain-specific heuristics
    7. Check response time — should be under 10 seconds
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. POST /api/critique with real image returns structured critique JSON
3. Response has 4 sections: what_works, usability_risks, visual_hierarchy, improvements
4. Each section has 2-4 points with summary and detail
5. Changing context changes the critique content (domain-specific)
6. Changing tone changes the language style
7. Response time is under 10 seconds
8. Invalid requests still return 400
</verification>

<success_criteria>
- Real Claude API calls replace mock data
- Structured output via tool_use guarantees consistent JSON
- Industry context changes critique content
- Tone changes critique delivery
- Response time under 10 seconds
- Error handling covers API key and general failures
</success_criteria>

<output>
After completion, create `.planning/phases/02-ai-engine/02-02-SUMMARY.md`
</output>
